local player = game.Players.LocalPlayer
local RunService = game:GetService("RunService")

local function getCharacter()
    return player.Character or player.CharacterAdded:Wait()
end

local Character = getCharacter()
local Humanoid = Character:WaitForChild("Humanoid")
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

-- T·∫£i Rayfield t·ª´ ngu·ªìn tr·ª±c tuy·∫øn
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local soundMenu = Instance.new("Sound", game.Players.LocalPlayer:WaitForChild("PlayerGui"))
soundMenu.SoundId = "rbxassetid://8120936755"
soundMenu.Volume = 1

local sound = Instance.new("Sound", game.Players.LocalPlayer:WaitForChild("PlayerGui"))
sound.SoundId = "rbxassetid://3779053277"
sound.Volume = 1

soundMenu:Play()
-- T·∫°o m·ªôt ch·ªß ƒë·ªÅ t√πy ch·ªânh
-- ƒê√¢y l√† n∆°i b·∫°n ƒë·ªãnh nghƒ©a m√†u s·∫Øc v√† giao di·ªán cho menu c·ªßa m√¨nh
local CustomTheme = {
    TextColor = Color3.fromRGB(255, 255, 255), -- M√†u ch·ªØ tr·∫Øng
    Background = Color3.fromRGB(0, 0, 0), -- M√†u n·ªÅn ƒëen
    Topbar = Color3.fromRGB(34, 34, 34), -- M√†u thanh tr√™n c√πng
    Shadow = Color3.fromRGB(255, 255, 255), -- Hi·ªáu ·ª©ng b√≥ng
    NotificationBackground = Color3.fromRGB(20, 20, 20), -- N·ªÅn c·ªßa th√¥ng b√°o
    NotificationActionsBackground = Color3.fromRGB(230, 230, 230), -- N·ªÅn c·ªßa khu v·ª±c h√†nh ƒë·ªông th√¥ng b√°o
    TabBackground = Color3.fromRGB(0, 128, 0), -- M√†u xanh l√° c√¢y cho tab
    TabStroke = Color3.fromRGB(255, 255, 255), -- Vi·ªÅn tab m√†u tr·∫Øng
    TabBackgroundSelected = Color3.fromRGB(0, 128, 0), -- M√†u xanh l√° s√°ng h∆°n khi tab ƒë∆∞·ª£c ch·ªçn
    TabTextColor = Color3.fromRGB(255, 255, 255), -- M√†u ch·ªØ tr·∫Øng trong tab
    SelectedTabTextColor = Color3.fromRGB(255, 255, 255), -- M√†u ch·ªØ ƒëen khi tab ƒë∆∞·ª£c ch·ªçn
    ElementBackground = Color3.fromRGB(35, 35, 35), -- N·ªÅn c·ªßa t·ª´ng ph·∫ßn t·ª≠ giao di·ªán
    ElementBackgroundHover = Color3.fromRGB(40, 40, 40), -- N·ªÅn ph·∫ßn t·ª≠ khi di chu·ªôt v√†o
    SecondaryElementBackground = Color3.fromRGB(25, 25, 25), -- N·ªÅn c·ªßa ph·∫ßn t·ª≠ ph·ª•
    ElementStroke = Color3.fromRGB(255, 255, 255), -- Vi·ªÅn ph·∫ßn t·ª≠ m√†u tr·∫Øng
    SecondaryElementStroke = Color3.fromRGB(40, 40, 40), -- Vi·ªÅn ph·∫ßn t·ª≠ ph·ª•
    SliderBackground = Color3.fromRGB(255, 215, 0), -- N·ªÅn thanh tr∆∞·ª£t m√†u v√†ng
    SliderProgress = Color3.fromRGB(255, 215, 0), -- M√†u ti·∫øn tr√¨nh thanh tr∆∞·ª£t v√†ng
    SliderStroke = Color3.fromRGB(255, 255, 0), -- Vi·ªÅn thanh tr∆∞·ª£t m√†u v√†ng s√°ng h∆°n
    ToggleBackground = Color3.fromRGB(30, 30, 30), -- N·ªÅn n√∫t b·∫≠t/t·∫Øt
    ToggleEnabled = Color3.fromRGB(0, 146, 214), -- M√†u khi b·∫≠t
    ToggleDisabled = Color3.fromRGB(100, 100, 100), -- M√†u khi t·∫Øt
    ToggleEnabledStroke = Color3.fromRGB(255, 255, 255), -- Vi·ªÅn khi b·∫≠t
    ToggleDisabledStroke = Color3.fromRGB(255, 255, 255), -- Vi·ªÅn khi t·∫Øt
    ToggleEnabledOuterStroke = Color3.fromRGB(255, 255, 255), -- Vi·ªÅn ngo√†i khi b·∫≠t
    ToggleDisabledOuterStroke = Color3.fromRGB(255, 255, 255), -- Vi·ªÅn ngo√†i khi t·∫Øt
    DropdownSelected = Color3.fromRGB(40, 40, 40), -- M√†u khi m·ª•c dropdown ƒë∆∞·ª£c ch·ªçn
    DropdownUnselected = Color3.fromRGB(30, 30, 30), -- M√†u khi m·ª•c dropdown ch∆∞a ƒë∆∞·ª£c ch·ªçn
    InputBackground = Color3.fromRGB(30, 30, 30), -- N·ªÅn c·ªßa √¥ nh·∫≠p li·ªáu
    InputStroke = Color3.fromRGB(255, 255, 255), -- Vi·ªÅn c·ªßa √¥ nh·∫≠p li·ªáu
    PlaceholderColor = Color3.fromRGB(178, 178, 178) -- M√†u ch·ªØ g·ª£i √Ω trong √¥ nh·∫≠p li·ªáu
}


-- T·∫°o c·ª≠a s·ªï giao di·ªán ch√≠nh v·ªõi ch·ªß ƒë·ªÅ t√πy ch·ªânh
local Window = Rayfield:CreateWindow({
   Name = "Fe Universal Menu V1", -- T√™n c·ªßa c·ª≠a s·ªï giao di·ªán
   Icon = 0, -- ID icon (c√≥ th·ªÉ thay ƒë·ªïi)
   LoadingTitle = "Loading......", -- Ti√™u ƒë·ªÅ khi ƒëang t·∫£i
   LoadingSubtitle = "by NCXKayy", -- D√≤ng ph·ª• khi t·∫£i
   Theme = CustomTheme, -- √Åp d·ª•ng ch·ªß ƒë·ªÅ t√πy ch·ªânh
   ToggleUIKeybind = "K", -- Ph√≠m t·∫Øt ƒë·ªÉ b·∫≠t/t·∫Øt giao di·ªán
   DisableRayfieldPrompts = false, -- T·∫Øt th√¥ng b√°o m·∫∑c ƒë·ªãnh c·ªßa Rayfield n·∫øu c·∫ßn
   DisableBuildWarnings = false, -- T·∫Øt c·∫£nh b√°o bi√™n d·ªãch n·∫øu mu·ªën
   ConfigurationSaving = { -- C·∫•u h√¨nh l∆∞u tr·ªØ
      Enabled = true, -- B·∫≠t l∆∞u c·∫•u h√¨nh
      FolderName = "ThaytuberVN_Hub", -- T√™n th∆∞ m·ª•c l∆∞u
      FileName = "ThaytuberVN Hub" -- T√™n t·ªáp c·∫•u h√¨nh
   },

    KeySystem = false, -- B·∫≠t h·ªá th·ªëng key
    KeySettings = {
        Title = "Fe Universal Menu | Key",
        Subtitle = "Key c√≥ trong server Discord",
        Note = "Tham gia server ƒë·ªÉ l·∫•y key",
        FileName = "Key", -- T√™n file l∆∞u key
        SaveKey = true, -- L∆∞u key c·ªßa ng∆∞·ªùi d√πng
        GrabKeyFromSite = false, -- L·∫•y key t·ª´ trang web
        Key = {"thaytubervn"} -- Danh s√°ch key h·ª£p l·ªá
    }
})

-- T·∫°o c√°c tab trong giao di·ªán
local Tab1 = Window:CreateTab("Players", 4483362458) -- Tab qu·∫£n l√Ω ng∆∞·ªùi ch∆°i
local Tab2 = Window:CreateTab("Aimbot", 4483362458) -- Tab d√†nh cho c√°c t√πy ch·ªânh ESP
local Tab3 = Window:CreateTab("ESP", 4483362458) -- Tab ƒë·ªÉ ch·∫°y script t√πy ch·ªânh
-----------------------
local flying = false
local invisible_enabled = false
local invis_on = false
local Noclip = false
local TeleportEnabled = false
local InfiniteJumpEnabled = false
local following = false -- Bi·∫øn ki·ªÉm so√°t tr·∫°ng th√°i theo d√µi
local FullBrightEnabled = false
local viewingPlayer = false
local FlySpeed = 100 -- Gi√° tr·ªã t·ªëc ƒë·ªô m·∫∑c ƒë·ªãnh

local UserInputService = game:GetService("UserInputService")
local originalAmbient = game:GetService("Lighting").Ambient
local originalBrightness = game:GetService("Lighting").Brightness
local originalFogEnd = game:GetService("Lighting").FogEnd
local originalCameraSubject = game.Workspace.CurrentCamera.CameraSubject
local nega = true
local SelectedPlayer = nil
--! N√∫t ch·ªçn ng·∫´u nhi√™n ng∆∞·ªùi ch∆°i
local lastSelectedPlayers = {} -- Danh s√°ch l∆∞u tr·ªØ hai ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t


local function fly()
    sound:Play()
    local character = game.Players.LocalPlayer.Character
    if not character then return end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    local humanoid = character:FindFirstChildWhichIsA("Humanoid")
    if not humanoid then return end

    flying = true
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)

    local bv = Instance.new("BodyVelocity")
    local bg = Instance.new("BodyGyro")
    bv.MaxForce = Vector3.new(9e4, 9e4, 9e4)
    bg.CFrame = hrp.CFrame
    bg.MaxTorque = Vector3.new(9e4, 9e4, 9e4)
    bg.P = 9e4
    bv.Parent = hrp
    bg.Parent = hrp

    local flycontrol = {F = 0, B = 0, L = 0, R = 0, U = 0, D = 0}

    local uis = game:GetService("UserInputService")
    uis.InputBegan:Connect(function(key, processed)
        if processed then return end
        local keyName = key.KeyCode.Name:lower()
        if keyName == "w" then flycontrol.F = 1
        elseif keyName == "s" then flycontrol.B = 1
        elseif keyName == "a" then flycontrol.L = 1
        elseif keyName == "d" then flycontrol.R = 1
        elseif keyName == "space" then flycontrol.U = 1
        elseif keyName == "leftcontrol" then flycontrol.D = 1
        end
    end)

    uis.InputEnded:Connect(function(key, processed)
        if processed then return end
        local keyName = key.KeyCode.Name:lower()
        if keyName == "w" then flycontrol.F = 0
        elseif keyName == "s" then flycontrol.B = 0
        elseif keyName == "a" then flycontrol.L = 0
        elseif keyName == "d" then flycontrol.R = 0
        elseif keyName == "space" then flycontrol.U = 0
        elseif keyName == "leftcontrol" then flycontrol.D = 0
        end
    end)

    local con = game:GetService("RunService").Stepped:Connect(function()
        if not flying then
            con:Disconnect()
            bv:Destroy()
            bg:Destroy()
        end
        humanoid.PlatformStand = true
        bv.Velocity =
            (workspace.CurrentCamera.CFrame.LookVector * (flycontrol.F - flycontrol.B) * FlySpeed) + 
            (workspace.CurrentCamera.CFrame.RightVector * (flycontrol.R - flycontrol.L) * FlySpeed) + 
            (workspace.CurrentCamera.CFrame.UpVector * (flycontrol.U - flycontrol.D) * FlySpeed)
        bg.CFrame = workspace.CurrentCamera.CFrame
    end)
    game.StarterGui:SetCore("SendNotification", {
        Title = "FLy (ON)",
        Duration = 3,
        Text = "FLy Turn On!"
    })
end

local function stopFlying()
    sound:Play()
    flying = false
    local character = game.Players.LocalPlayer.Character
    if character then
        local hrp = character:FindFirstChild("HumanoidRootPart")
        local humanoid = character:FindFirstChildWhichIsA("Humanoid")
        if hrp and humanoid then
            for _, obj in pairs(hrp:GetChildren()) do
                if obj:IsA("BodyVelocity") or obj:IsA("BodyGyro") then
                    obj:Destroy()
                end
            end
            humanoid.PlatformStand = false
            humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
        end
    end
    game.StarterGui:SetCore("SendNotification", {
        Title = "FLy (OFF)",
        Duration = 3,
        Text = "FLy Turn OFF!"
    })
end

local function setTransparency(character, transparency)
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") or part:IsA("Decal") then
            part.Transparency = transparency
        end
    end
end

local function toggleInvisibility()
    invis_on = not invis_on
    sound:Play()
    local player = game.Players.LocalPlayer
    local character = player.Character

    if invis_on then
        local savedpos = character.HumanoidRootPart.CFrame
        wait()
        character:MoveTo(Vector3.new(-25.95, 84, 3537.55))
        wait(.15)
        
        local Seat = Instance.new("Seat", game.Workspace)
        Seat.Anchored = false
        Seat.CanCollide = false
        Seat.Name = "invischair"
        Seat.Transparency = 1
        Seat.Position = Vector3.new(-25.95, 84, 3537.55)

        local Weld = Instance.new("Weld", Seat)
        Weld.Part0 = Seat
        Weld.Part1 = character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso")

        wait()
        Seat.CFrame = savedpos
        setTransparency(character, 0.5)

        game.StarterGui:SetCore("SendNotification", {
            Title = "Invisibility (ON)",
            Duration = 3,
            Text = "You have hidden!"
        })
    else
        local invisChair = workspace:FindFirstChild("invischair")
        if invisChair then
            invisChair:Destroy()
        end
        
        setTransparency(character, 0)
        character.HumanoidRootPart.Transparency = 1

        game.StarterGui:SetCore("SendNotification", {
            Title = "Invisibility (OFF)",
            Duration = 3,
            Text = "You are back to normal!"
        })
    end
end

local modifiedParts = {} -- Danh s√°ch l∆∞u c√°c kh·ªëi ƒë√£ b·ªã ch·ªânh s·ª≠a

local function onTouch(part)
    if Noclip and part.CanCollide == true then
        part.CanCollide = false -- Bi·∫øn ƒë·ªëi t∆∞·ª£ng th√†nh c√≥ th·ªÉ ƒëi xuy√™n qua
        table.insert(modifiedParts, part) -- L∆∞u l·∫°i kh·ªëi ƒë√£ b·ªã ch·ªânh
    end
end

local function toggleNoClip()
    Noclip = not Noclip -- ƒê·∫£o tr·∫°ng th√°i Noclip
    sound:Play()
    for _, v in pairs(player.Character:GetDescendants()) do
        if v:IsA("BasePart") or v:IsA("MeshPart") or v:IsA("UnionOperation") then
            v.CanCollide = not Noclip -- Khi b·∫≠t, t·∫Øt va ch·∫°m; Khi t·∫Øt, b·∫≠t l·∫°i va ch·∫°m

            if Noclip then
                v.Touched:Connect(onTouch) -- K·∫øt n·ªëi s·ª± ki·ªán khi b·∫≠t
            end
        end
    end

    -- Khi t·∫Øt Noclip, kh√¥i ph·ª•c c√°c kh·ªëi ƒë√£ b·ªã ch·ªânh
    if not Noclip then
        for _, part in pairs(modifiedParts) do
            if part then
                part.CanCollide = true -- ƒê·∫∑t l·∫°i va ch·∫°m cho c√°c kh·ªëi ƒë√£ b·ªã ch·ªânh s·ª≠a
            end
        end
        modifiedParts = {} -- X√≥a danh s√°ch sau khi kh√¥i ph·ª•c
    end

    game.StarterGui:SetCore("SendNotification", {
        Title = "Noclip",
        Duration = 3,
        Text = "Noclip is now - " .. tostring(Noclip)
    })
end

local function infJump()
    sound:Play()
    game:GetService("UserInputService").JumpRequest:Connect(function()
        if InfiniteJumpEnabled then
            local humanoid = game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end
        end
    end)
    game.StarterGui:SetCore("SendNotification", {
        Title = "InfJump",
        Duration = 3,
        Text = "InfJump is now - " .. tostring(InfiniteJumpEnabled)
    })
end

-- H√†m ki·ªÉm tra input v√† ƒë·∫∑t l·∫°i gi√° tr·ªã n·∫øu tr·ªëng
local function handleKeybindInput(input, defaultValue)
    return (input and input ~= "") and input:upper() or defaultValue
end

local function toggleFullBright()
    local lighting = game:GetService("Lighting")
    FullBrightEnabled = not FullBrightEnabled

    if FullBrightEnabled then
        sound:Play()
        lighting.Ambient = Color3.fromRGB(255, 255, 255)
        lighting.Brightness = 1
        lighting.FogEnd = 1e10

        -- T·∫Øt c√°c hi·ªáu ·ª©ng l√†m m·ªù
        for _, v in pairs(lighting:GetDescendants()) do
            if v:IsA("BloomEffect") or v:IsA("BlurEffect") or v:IsA("ColorCorrectionEffect") or v:IsA("SunRaysEffect") then
                v.Enabled = false
            end
        end

        -- Th√™m √°nh s√°ng v√†o nh√¢n v·∫≠t
        spawn(function()
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character
            repeat wait() until character ~= nil

            if not character.HumanoidRootPart:FindFirstChildWhichIsA("PointLight") then
                local headlight = Instance.new("PointLight", character.HumanoidRootPart)
                headlight.Brightness = 1
                headlight.Range = 60
                headlight.Name = "CustomLight"
            end
        end)
    else
        sound:Play()
        -- Kh√¥i ph·ª•c √°nh s√°ng m·∫∑c ƒë·ªãnh
        lighting.Ambient = originalAmbient
        lighting.Brightness = originalBrightness
        lighting.FogEnd = originalFogEnd

        for _, v in pairs(lighting:GetDescendants()) do
            if v:IsA("BloomEffect") or v:IsA("BlurEffect") or v:IsA("ColorCorrectionEffect") or v:IsA("SunRaysEffect") then
                v.Enabled = true
            end
        end

        -- X√≥a √°nh s√°ng nh√¢n v·∫≠t khi t·∫Øt
        local player = game:GetService("Players").LocalPlayer
        local character = player.Character
        if character and character.HumanoidRootPart then
            local headlight = character.HumanoidRootPart:FindFirstChild("CustomLight")
            if headlight then
                headlight:Destroy()
            end
        end
    end
end

local function toggleKillbrick()
    nega = not nega

    local player = game:GetService("Players").LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

    local parts = workspace:GetPartBoundsInRadius(humanoidRootPart.Position, 10)
    for _, part in ipairs(parts) do
        part.CanTouch = nega
    end
end

---------------------
local FlyKeybind = "F" -- Ph√≠m m·∫∑c ƒë·ªãnh
local InvisKeybind = "G" -- Ph√≠m m·∫∑c ƒë·ªãnh
local NoclipKey = "X" -- B·∫°n c√≥ th·ªÉ thay ƒë·ªïi ph√≠m t·∫Øt t·∫°i ƒë√¢y
local InfJumpKey = "Z" -- B·∫°n c√≥ th·ªÉ thay ƒë·ªïi ph√≠m t·∫Øt t·∫°i ƒë√¢y

local Tile1 = Tab1:CreateSection("Movement")

-- T·ªëc ƒë·ªô ch·∫°y
local WalkSpeedSlider = Tab1:CreateSlider({
    Name = "Walk Speed",
    Range = {16, 300},
    Increment = 5,
    CurrentValue = Humanoid.WalkSpeed,
    Callback = function(Value)
        Humanoid.WalkSpeed = Value
    end
})

-- **Ch·ªânh ƒë·ªô cao khi nh·∫£y**
local JumpSlider = Tab1:CreateSlider({
    Name = "Jump height",
    Range = {7.2, 1000},
    Increment = 20,
    CurrentValue = 50,
    Callback = function(Value)
        game.Players.LocalPlayer.Character.Humanoid.UseJumpPower = false
        game.Players.LocalPlayer.Character.Humanoid.JumpHeight = Value
    end
})

-- **Ch·ªânh t·ªëc ƒë·ªô bay**
local FlySpeedSlider = Tab1:CreateSlider({
    Name = "Flight speed",
    Range = {50, 1000},
    Default = FlySpeed, -- Gi√° tr·ªã m·∫∑c ƒë·ªãnh
    Increment = 10,
    CurrentValue = FlySpeed,
    Callback = function(Value)
        FlySpeed = Value
    end
})

local FlyButton = Tab1:CreateButton({
    Name = "Fly",
    Callback = function()
        if flying then
            stopFlying()
        else
            fly()
        end
    end
})

-- N√∫t b·∫≠t/t·∫Øt teleport
local TeleportButton = Tab1:CreateButton({
    Name = "CLick Teleport",
    Callback = function()
        TeleportEnabled = not TeleportEnabled
        sound:Play()
        Rayfield:Notify({
            Title = "Notification",
            Content = TeleportEnabled and "Teleport is on!" or "Teleport is off!",
            Duration = 2.5
        })
    end
})

local InfJumpButton = Tab1:CreateButton({
    Name = "Infinite Jump",
    Callback = function()
        InfiniteJumpEnabled = not InfiniteJumpEnabled
        if InfiniteJumpEnabled then
            infJump()
        end
    end
})


local Tile2 = Tab1:CreateSection("Players")
-- Th√™m n√∫t b·∫≠t/t·∫Øt ·∫©n th√¢n v√†o menu Rayfield
local InvisButton = Tab1:CreateButton({
    Name = "Invisible",
    Callback = function()
        toggleInvisibility()
    end,
})

local NoclipButton = Tab1:CreateButton({
    Name = "Noclip",
    Callback = function()
        toggleNoClip()
    end,
})
-- T·∫°o n√∫t b·∫≠t/t·∫Øt Full Bright
local FullBrightButton = Tab1:CreateButton({
    Name = "Full Bright",
    Callback = function()
        toggleFullBright()
    end,
})

Tab1:CreateButton({
    Name = "Killbrick Toggle",
    Callback = function()
        toggleKillbrick()
        if nega then
            sound:Play()
            Rayfield:Notify({
                Title = "Killbrick",
                Content = "Killbrick is now OFF",
                Duration = 2
            })
        else
            sound:Play()
            Rayfield:Notify({
                Title = "Killbrick",
                Content = "Killbrick is now ON",
                Duration = 2
            })
        end
    end
})


local Tile3 = Tab1:CreateSection("OtherPlayers")
--! T·∫°o textbox nh·∫≠p t√™n ng∆∞·ªùi ch∆°i
local PlayerTextbox = Tab1:CreateInput({
    Name = "Enter player name or nickname",
    PlaceholderText = "Enter a partial player name",
    Callback = function(input)
        SelectedPlayer = nil
        for _, p in ipairs(game.Players:GetPlayers()) do
            if string.find(string.lower(p.Name), string.lower(input)) then
                SelectedPlayer = p
                print("You have entered: " .. input .. " - Find: " .. p.Name)
                break
            end
        end
    end
})


local RandomPlayerButton = Tab1:CreateButton({
    Name = "Randomly Select Players",
    Callback = function()
        local players = game.Players:GetPlayers()
        local localPlayer = game.Players.LocalPlayer

        -- Lo·∫°i b·ªè ng∆∞·ªùi ch∆°i ch√≠nh m√¨nh kh·ªèi danh s√°ch
        for i = #players, 1, -1 do
            if players[i] == localPlayer then
                table.remove(players, i)
                break
            end
        end

        -- Lo·∫°i b·ªè hai ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t t·ª´ danh s√°ch
        for _, lastPlayer in ipairs(lastSelectedPlayers) do
            for i = #players, 1, -1 do
                if players[i] == lastPlayer then
                    table.remove(players, i)
                    break
                end
            end
        end

        if #players > 0 then
            sound:Play()
            SelectedPlayer = players[math.random(1, #players)]
            PlayerTextbox.Text = SelectedPlayer.Name -- C·∫≠p nh·∫≠t t√™n v√†o textbox
            
            -- L·∫•y URL ·∫£nh ƒë·∫°i di·ªán c·ªßa ng∆∞·ªùi ch∆°i
            local avatarUrl = "https://www.roblox.com/headshot-thumbnail/image?userId=" .. SelectedPlayer.UserId .. "&width=150&height=150&format=png"

            -- Hi·ªÉn th·ªã th√¥ng b√°o v·ªõi avatar
            game.StarterGui:SetCore("SendNotification", {
                Title = "The player is chosen",
                Text = SelectedPlayer.Name,
                Duration = 4,
                Icon = avatarUrl -- Hi·ªÉn th·ªã avatar
            })

            print("Randomly selected player: " .. SelectedPlayer.Name)

            -- C·∫≠p nh·∫≠t danh s√°ch ng∆∞·ªùi ch∆°i ƒë√£ ch·ªçn g·∫ßn nh·∫•t
            table.insert(lastSelectedPlayers, SelectedPlayer)
            if #lastSelectedPlayers > 2 then
                table.remove(lastSelectedPlayers, 1) -- ƒê·∫£m b·∫£o danh s√°ch ch·ªâ ch·ª©a hai ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t
            end
        else
            sound:Play()
            game.StarterGui:SetCore("SendNotification", {
                Title = "Server",
                Text = "No One Found",
                Duration = 4,
            })
            print("No players found in server!")
        end
    end
})


--! N√∫t teleport ƒë·∫øn ng∆∞·ªùi ch∆°i ƒë√£ nh·∫≠p
local TeleportToPlayer = Tab1:CreateButton({
    Name = "Teleport to player",
    Callback = function()
        if SelectedPlayer and SelectedPlayer.Character and SelectedPlayer.Character:FindFirstChild("HumanoidRootPart") then
            sound:Play()
            player.Character.HumanoidRootPart.CFrame = SelectedPlayer.Character.HumanoidRootPart.CFrame
            print("Teleported to player: " .. SelectedPlayer.Name)
        else
            sound:Play()
            print("Cannot teleport! Check player name.")
        end
    end
})

--! N√∫t b·∫≠t/t·∫Øt theo d√µi
local FollowPlayer = Tab1:CreateButton({
    Name = "Enable/Disable Tracking",
    Callback = function()
        following = not following -- ƒê·∫£o tr·∫°ng th√°i theo d√µi

        if following then
            sound:Play()
            if SelectedPlayer and SelectedPlayer.Character and SelectedPlayer.Character:FindFirstChild("HumanoidRootPart") then
                spawn(function()
                    while following do
                        if not SelectedPlayer or not SelectedPlayer.Character or not SelectedPlayer.Character:FindFirstChild("HumanoidRootPart") then
                            following = false
                            break
                        end

                        -- L·∫•y v·ªã tr√≠ c·ªßa ng∆∞·ªùi ch∆°i m·ª•c ti√™u
                        local targetPosition = SelectedPlayer.Character.HumanoidRootPart.Position

                        -- ƒêi·ªÅu ch·ªânh v·ªã tr√≠ g·∫ßn h∆°n ph√≠a sau l∆∞ng v√† l∆° l·ª≠ng
                        local offset = Vector3.new(0, 5, -1) -- Gi·ªØ kho·∫£ng c√°ch ph√≠a sau ch·ªâ 1 ƒë∆°n v·ªã
                        local newPosition = targetPosition + SelectedPlayer.Character.HumanoidRootPart.CFrame.LookVector * offset.Z + Vector3.new(0, offset.Y, 0)

                        -- D·ªãch chuy·ªÉn ng∆∞·ªùi ch∆°i theo v·ªã tr√≠ m·ªõi
                        player.Character:SetPrimaryPartCFrame(CFrame.new(newPosition))

                        task.wait()
                    end
                end)
            else
            end
        else
            sound:Play()
        end
    end
})

--! N√∫t chuy·ªÉn g√≥c nh√¨n
local ViewPlayerButton = Tab1:CreateButton({
    Name = "Change Perspective",
    Callback = function()
        local camera = game.Workspace.CurrentCamera
        if viewingPlayer then
            sound:Play()
            -- Tr·ªü v·ªÅ g√≥c nh√¨n ban ƒë·∫ßu
            camera.CameraSubject = originalCameraSubject
            viewingPlayer = false
        else
            sound:Play()
            -- Chuy·ªÉn g√≥c nh√¨n sang ng∆∞·ªùi ch∆°i ƒë√£ nh·∫≠p
            if SelectedPlayer and SelectedPlayer.Character and SelectedPlayer.Character:FindFirstChildWhichIsA("Humanoid") then
                camera.CameraSubject = SelectedPlayer.Character:FindFirstChildWhichIsA("Humanoid")
                viewingPlayer = true
            else
            end
        end
    end
})


local Tile4 = Tab1:CreateSection("SettingKey")
-- Fly --
local KeybindInput = Tab1:CreateInput({
    Name = "Fly On/Off Key",
    PlaceholderText = FlyKeybind,
    RemoveTextAfterFocusLost = false,
    Flag = "Fly_Key",
    Callback = function(input)
        FlyKeybind = handleKeybindInput(input, "F") -- S·ª≠ d·ª•ng gi√° tr·ªã m·∫∑c ƒë·ªãnh n·∫øu input r·ªóng
    end
})

-- Invisible --
local KeybindInput2 = Tab1:CreateInput({
    Name = "Invisible on/off key",
    PlaceholderText = InvisKeybind,
    RemoveTextAfterFocusLost = false,
    Flag = "Invisible_Key",
    Callback = function(input)
        InvisKeybind = handleKeybindInput(input, "G")
    end
})

-- Noclip --
local KeybindInput3 = Tab1:CreateInput({
    Name = "Noclip on/off key",
    PlaceholderText = NoclipKey,
    RemoveTextAfterFocusLost = false,
    Flag = "Noclip_Key",
    Callback = function(input)
        NoclipKey = handleKeybindInput(input, "X")
    end
})

-- InfJump --
local KeybindInput4 = Tab1:CreateInput({
    Name = "InfJump on/off key",
    PlaceholderText = InfJumpKey,
    RemoveTextAfterFocusLost = false,
    Flag = "InfJump_Key",
    Callback = function(input)
        InfJumpKey = handleKeybindInput(input, "Z")
    end
})

----------------------------
game:GetService("UserInputService").InputBegan:Connect(function(key, processed)
    if processed then return end
    local keyName = key.KeyCode.Name:upper()

    if keyName == FlyKeybind then
        if flying then stopFlying() else fly() end
    elseif keyName == InvisKeybind then
        toggleInvisibility()
    elseif keyName == NoclipKey then
        toggleNoClip()
    elseif keyName == InfJumpKey then
        infJump()
    end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)

    if input.UserInputType == Enum.UserInputType.MouseButton1 and not gameProcessed and TeleportEnabled then
        local player = game.Players.LocalPlayer
        if player and player.Character and player.Character.PrimaryPart then
            local mouse = player:GetMouse()
            player.Character:SetPrimaryPartCFrame(CFrame.new(mouse.Hit.p))
        end
    end
end)



------------------------------------------------------
----------TAB 2 _____________________________________-

local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local TeleportService = game:GetService("TeleportService")
local players = game:GetService("Players")
local wrk = game:GetService("Workspace")
local plr = players.LocalPlayer
local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
local humanoid = plr.Character:FindFirstChild("Humanoid")

local function onCharacterAdded(character)
    hrp = character:WaitForChild("HumanoidRootPart")
    humanoid = character:WaitForChild("Humanoid")
end

plr.CharacterAdded:Connect(onCharacterAdded)

if plr.Character then
    onCharacterAdded(plr.Character)
end

local camera = wrk.CurrentCamera
local mouse = plr:GetMouse()

local httprequest = (syn and syn.request) or (http and http.request) or http_request or (fluxus and fluxus.request) or request

local hue = 0
local rainbowFov = true
local rainbowSpeed = 0.005

local aimFov = 100
local aimParts = {"Head"}
local aiming = false
local predictionStrength = 0
local smoothing = 0

local aimbotEnabled = false
local wallCheck = false
local stickyAimEnabled = false
local teamCheck = false
local healthCheck = false
local minHealth = 0

local antiAim = false

local antiAimAmountX = 0
local antiAimAmountY = -100
local antiAimAmountZ = 0

local antiAimMethod = "Reset Velo"

local randomVeloRange = 100

local spinBot = false
local spinBotSpeed = 20

local circleColor = Color3.fromRGB(255, 0, 0)
local targetedCircleColor = Color3.fromRGB(0, 255, 0)

local aimViewerEnabled = false
local ignoreSelf = true

local fovCircle = Drawing.new("Circle")
fovCircle.Thickness = 2
fovCircle.Radius = aimFov
fovCircle.Filled = false
fovCircle.Color = circleColor
fovCircle.Visible = false

local currentTarget = nil

local function checkTeam(player)
    if teamCheck and player.Team == plr.Team then
        return true
    end
    return false
end

local function checkWall(targetCharacter)
    local targetHead = targetCharacter:FindFirstChild("Head")
    if not targetHead then return true end

    local origin = camera.CFrame.Position
    local direction = (targetHead.Position - origin).unit * (targetHead.Position - origin).magnitude
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {plr.Character, targetCharacter}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

    local raycastResult = wrk:Raycast(origin, direction, raycastParams)
    return raycastResult and raycastResult.Instance ~= nil
end

local function getClosestPart(character)
    local closestPart = nil
    local shortestCursorDistance = aimFov * 0.8 -- Gi·∫£m ph·∫°m vi ng·∫Øm ƒë·ªÉ tƒÉng ƒë·ªô ch√≠nh x√°c
    local cameraPos = camera.CFrame.Position

    for _, partName in ipairs(aimParts) do
        local part = character:FindFirstChild(partName)
        if part then
            local partPos = camera:WorldToViewportPoint(part.Position)
            local screenPos = Vector2.new(partPos.X, partPos.Y)
            local cursorDistance = (screenPos - Vector2.new(mouse.X, mouse.Y)).Magnitude

            if cursorDistance < shortestCursorDistance and partPos.Z > 0 then
                shortestCursorDistance = cursorDistance
                closestPart = part
            end
        end
    end

    return closestPart
end

local function getTarget()
    local nearestPlayer = nil
    local closestPart = nil
    local shortestCursorDistance = aimFov * 0.75 -- TƒÉng ƒë·ªô ch√≠nh x√°c b·∫±ng c√°ch gi·∫£m ph·∫°m vi t√¨m ki·∫øm

    for _, player in ipairs(players:GetPlayers()) do
        if player ~= plr and player.Character and not checkTeam(player) then
            if player.Character.Humanoid.Health >= minHealth or not healthCheck then
                local targetPart = getClosestPart(player.Character)
                if targetPart then
                    local screenPos = camera:WorldToViewportPoint(targetPart.Position)
                    local cursorDistance = (Vector2.new(screenPos.X, screenPos.Y) - Vector2.new(mouse.X, mouse.Y)).Magnitude

                    if cursorDistance < shortestCursorDistance then
                        if not wallCheck or not checkWall(player.Character) then
                            shortestCursorDistance = cursorDistance
                            nearestPlayer = player
                            closestPart = targetPart
                        end
                    end
                end
            end
        end
    end

    return nearestPlayer, closestPart
end


local function predict(player, part)
    if player and part then
        local velocity = player.Character.HumanoidRootPart.Velocity
        local predictedPosition = part.Position + (velocity * predictionStrength) * 0.5 -- Gi·∫£m s·ª©c m·∫°nh d·ª± ƒëo√°n
        return predictedPosition
    end
    return nil
end

local function smooth(from, to)
    return from:Lerp(to, smoothing * 0.8) -- TƒÉng ƒë·ªô b√°m s√°t m·ª•c ti√™u
end

local function aimAt(player, part)
    local predictedPosition = predict(player, part)
    if predictedPosition then
        if player.Character.Humanoid.Health >= minHealth or not healthCheck then
            camera.CFrame = CFrame.new(camera.CFrame.Position, predictedPosition)
        end
    end
end




RunService.RenderStepped:Connect(function()
    if aimbotEnabled then
        local offset = 50
        fovCircle.Position = Vector2.new(mouse.X, mouse.Y + offset)

        if rainbowFov then
            hue = hue + rainbowSpeed
            if hue > 1 then hue = 0 end
            fovCircle.Color = Color3.fromHSV(hue, 1, 1)
        else
            if aiming and currentTarget then
                fovCircle.Color = targetedCircleColor
            else
                fovCircle.Color = circleColor
            end
        end

        if aiming then
            if stickyAimEnabled and currentTarget then
                local headPos = camera:WorldToViewportPoint(currentTarget.Character.Head.Position)
                local screenPos = Vector2.new(headPos.X, headPos.Y)
                local cursorDistance = (screenPos - Vector2.new(mouse.X, mouse.Y)).Magnitude

                if cursorDistance > aimFov or (wallCheck and checkWall(currentTarget.Character)) or checkTeam(currentTarget) then
                    currentTarget = nil
                end
            end

            if not stickyAimEnabled or not currentTarget then
                local target, targetPart = getTarget()
                currentTarget = target
                currentTargetPart = targetPart
            end

            if currentTarget and currentTargetPart then
                aimAt(currentTarget, currentTargetPart)
            end
        else
            currentTarget = nil
        end
    end
end)

RunService.Heartbeat:Connect(function()
    if antiAim then
        if antiAimMethod == "Reset Velo" then
            local vel = hrp.Velocity
            hrp.Velocity = Vector3.new(antiAimAmountX, antiAimAmountY, antiAimAmountZ)
            RunService.RenderStepped:Wait()
            hrp.Velocity = vel
        elseif antiAimMethod == "Reset Pos [BROKEN]" then
            local pos = hrp.CFrame
            hrp.Velocity = Vector3.new(antiAimAmountX, antiAimAmountY, antiAimAmountZ)
            RunService.RenderStepped:Wait()
            hrp.CFrame = pos
        elseif antiAimMethod == "Random Velo" then
            local vel = hrp.Velocity
            local a = math.random(-randomVeloRange,randomVeloRange)
            local s = math.random(-randomVeloRange,randomVeloRange)
            local d = math.random(-randomVeloRange,randomVeloRange)
            hrp.Velocity = Vector3.new(a,s,d)
            RunService.RenderStepped:Wait()
            hrp.Velocity = vel
        end
    end
end)

mouse.Button2Down:Connect(function()
    if aimbotEnabled then
        aiming = true
    end
end)

mouse.Button2Up:Connect(function()
    if aimbotEnabled then
        aiming = false
    end
end)

local Tile1 = Tab2:CreateSection("Aimbot")

local aimbot = Tab2:CreateToggle({
    Name = "Aimbot",
    CurrentValue = false,
    Flag = "Aimbot",
    Callback = function(Value)
        sound:Play()
        aimbotEnabled = Value
        fovCircle.Visible = Value
    end
})

local aimpart = Tab2:CreateDropdown({
    Name = "Aim Part",
    Options = {"Head","HumanoidRootPart","Left Arm","Right Arm","Torso","Left Leg","Right Leg"},
    CurrentOption = {"Head"},
    MultipleOptions = true,
    Flag = "AimPart",
    Callback = function(Options)
        aimParts = Options
    end,
 })

 
local fovvisibility = Tab2:CreateToggle({
    Name = "Fov Visibility",
    CurrentValue = true,
    Flag = "FovVisibility",
    Callback = function(Value)
        sound:Play()
        fovCircle.Visible = Value
    end
})

local aimbotfov = Tab2:CreateSlider({
    Name = "Aimbot Fov",
    Range = {0, 1000},
    Increment = 1,
    CurrentValue = 100,
    Flag = "AimbotFov",
    Callback = function(Value)
        aimFov = Value
        fovCircle.Radius = aimFov
    end,
})

local Tile2 = Tab2:CreateSection("Setting")

local wallcheck = Tab2:CreateToggle({
    Name = "Wall Check",
    CurrentValue = false,
    Flag = "WallCheck",
    Callback = function(Value)
        sound:Play()
        wallCheck = Value
    end
})

local stickyaim = Tab2:CreateToggle({
    Name = "Sticky Aim",
    CurrentValue = false,
    Flag = "StickyAim",
    Callback = function(Value)
        sound:Play()
        stickyAimEnabled = Value
    end
})

local teamchecktoggle = Tab2:CreateToggle({
    Name = "Team Check",
    CurrentValue = false,
    Flag = "TeamCheck",
    Callback = function(Value)
        sound:Play()
        teamCheck = Value
    end
})

local healthchecktoggle = Tab2:CreateToggle({
    Name = "Health Check",
    CurrentValue = false,
    Flag = "HealthCheck",
    Callback = function(Value)
        sound:Play()
        healthCheck = Value
    end
})

local minhealth = Tab2:CreateSlider({
    Name = "Min Health",
    Range = {0, 100},
    Increment = 1,
    CurrentValue = 0,
    Flag = "MinHealth",
    Callback = function(Value)
        minHealth = Value
    end,
})

local circlecolor = Tab2:CreateColorPicker({
    Name = "Fov Color",
    Color = circleColor,
    Callback = function(Color)
        circleColor = Color
        fovCircle.Color = Color
    end
})

local targetedcirclecolor = Tab2:CreateColorPicker({
    Name = "Targeted Fov Color",
    Color = targetedCircleColor,
    Callback = function(Color)
        targetedCircleColor = Color
    end
})

local circlerainbow = Tab2:CreateToggle({
    Name = "Rainbow Fov",
    CurrentValue = true,
    Flag = "RainbowFov",
    Callback = function(Value)
        sound:Play()
        rainbowFov = Value
    end
})

------------------------------------------------------
--------ESP------------------------------------------

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local camera = workspace.CurrentCamera
local lplr = Players.LocalPlayer

-- Bi·∫øn to√†n c·ª•c v·ªÅ ESP
local nameEspEnabled = false
_G.TeamCheck = false
_G.ESPEnabled = false
_G.TeamCheckTracer = false
_G.TracerColor = Color3.new(1, 1, 1)
_G.RainbowEnabled = false
_G.BoxESPEnabled = false
_G.NameESPEnabled = false
_G.NameESPFont = 12

-- Bi·∫øn Box ESP
local BoxEnabled = false
local RainbowEnabled = false
local BoxStroke = 2
local BoxObjects = {}
local BoxConfig = { BoxTransparency = 0.5, MaxDistance = 5000 }

-- Bi·∫øn Tracer & Name ESP
local tracers = {}
local nameTags = {}



local function createTracer(player)
    if tracers[player] or player == lplr then return end -- Kh√¥ng li√™n k·∫øt ch√≠nh m√¨nh
    local tracer = Drawing.new("Line")
    tracer.Thickness = 1
    tracer.Color = _G.TracerColor or Color3.fromRGB(255, 0, 0)
    tracer.Visible = false
    tracers[player] = tracer
end

local function getRainbowColor()
    local hue = (tick() % 5) / 5
    return Color3.fromHSV(hue, 1, 1)
end


local function updateTracers()
    for player, tracer in pairs(tracers) do
        if _G.ESPEnabled and player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character.Humanoid.Health > 0 then
            -- Ki·ªÉm tra n·∫øu team check b·∫≠t v√† ng∆∞·ªùi ch∆°i c√πng ƒë·ªôi
            if _G.TeamCheckTracer and player.Team == lplr.Team then
                tracer.Visible = false -- ·∫®n tracer n·∫øu c√πng ƒë·ªôi
            else
                local screenPos, onScreen = camera:WorldToViewportPoint(player.Character.HumanoidRootPart.Position)
                if onScreen then
                    tracer.From = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y - 50)
                    tracer.To = Vector2.new(screenPos.X, screenPos.Y)
                    tracer.Visible = true
                    
                    -- Ki·ªÉm tra n·∫øu ch·∫ø ƒë·ªô Rainbow ƒëang b·∫≠t
                    if _G.RainbowEnabled then
                        tracer.Color = getRainbowColor()
                    else
                        tracer.Color = _G.TracerColor
                    end
                else
                    tracer.Visible = false
                end
            end
        else
            tracer.Visible = false
        end
    end
end



local function createNameTag(player)
    if nameTags[player] or player == lplr then return end -- Kh√¥ng hi·ªÉn th·ªã t√™n ch√≠nh m√¨nh
    local nameTag = Drawing.new("Text")
    nameTag.Text = player.Name
    nameTag.Size = _G.NameESPFont or 12
    nameTag.Color = Color3.fromRGB(255, 255, 255) -- M√†u m·∫∑c ƒë·ªãnh l√† tr·∫Øng
    nameTag.Center = true
    nameTag.Visible = false
    nameTags[player] = nameTag
end

local function updateNameTags()
    for player, nameTag in pairs(nameTags) do
        if nameEspEnabled and player.Character and player.Character:FindFirstChild("Head") then
            local screenPos, onScreen = camera:WorldToViewportPoint(player.Character.Head.Position)
            if onScreen then
                nameTag.Position = Vector2.new(screenPos.X, screenPos.Y - 20) -- ƒê·ªÉ t√™n ·ªü tr√™n ƒë·∫ßu
                nameTag.Visible = true
                nameTag.Color = _G.RainbowEnabled and getRainbowColor() or Color3.fromRGB(255, 255, 255) -- Rainbow m√†u n·∫øu b·∫≠t
            else
                nameTag.Visible = false
            end
        else
            nameTag.Visible = false
        end
    end
end


local function toggleNameESP(state)
    nameEspEnabled = state
    if state then
        sound:Play()
        for _, player in pairs(Players:GetPlayers()) do
            createNameTag(player)
        end
    else
        sound:Play()
        for _, nameTag in pairs(nameTags) do
            nameTag.Visible = false
        end
    end
end

--H√†m b·∫≠t/t·∫Øt Box
local function ToggleBox(state)
    sound:Play()
    BoxEnabled = state

    if not BoxEnabled then
        for _, boxObject in pairs(BoxObjects) do
            boxObject.Box.Visible = false
        end
    end
end

-- H√†m c·∫≠p nh·∫≠t ƒë·ªô d√†y vi·ªÅn
local function UpdateStroke(value)
    BoxStroke = tonumber(value) or 2 -- ƒê·∫£m b·∫£o gi√° tr·ªã h·ª£p l·ªá
    for _, boxObject in pairs(BoxObjects) do
        boxObject.Box.Thickness = BoxStroke
    end
end

-- H√†m t·∫°o Box cho ng∆∞·ªùi ch∆°i
local function CreateBoxForPlayer(player)
    if player == LocalPlayer then return end

    local boxObject = {
        Box = Drawing.new("Square"),
    }

    -- Thi·∫øt l·∫≠p Box
    boxObject.Box.Visible = false
    boxObject.Box.Thickness = BoxStroke
    boxObject.Box.Transparency = BoxConfig.BoxTransparency
    boxObject.Box.Filled = false
    boxObject.Box.Color = Color3.fromRGB(255, 255, 255) -- M·∫∑c ƒë·ªãnh l√† m√†u tr·∫Øng

    BoxObjects[player] = boxObject

    player.AncestryChanged:Connect(function()
        if not player:IsDescendantOf(game) then
            boxObject.Box:Remove()
            BoxObjects[player] = nil
        end
    end)
end

-- Th√™m Box cho t·∫•t c·∫£ ng∆∞·ªùi ch∆°i hi·ªán t·∫°i
for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        CreateBoxForPlayer(player)
    end
end


RunService.RenderStepped:Connect(function()
    if not BoxEnabled then return end

    for player, boxObject in pairs(BoxObjects) do
        local character = player.Character
        if not character or not character:FindFirstChild("HumanoidRootPart") then
            boxObject.Box.Visible = false
            continue
        end

        -- üî• Ki·ªÉm tra Team Check (N·∫øu b·∫≠t th√¨ Box kh√¥ng hi·ªÉn th·ªã tr√™n ƒë·ªìng ƒë·ªôi)
        if _G.TeamCheck then
            if player.Team == lplr.Team then
                boxObject.Box.Visible = false
                continue
            end
        end

        -- üî• Ki·ªÉm tra n·∫øu ng∆∞·ªùi ch∆°i l√† ch√≠nh b·∫°n
        if player == lplr then
            boxObject.Box.Visible = false
            continue
        end

        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        local vector, onScreen = camera:WorldToViewportPoint(humanoidRootPart.Position)
        local distance = (humanoidRootPart.Position - camera.CFrame.Position).Magnitude

        if onScreen and distance <= BoxConfig.MaxDistance then
            local topPosition = humanoidRootPart.Position + Vector3.new(0, 3, 0)
            local bottomPosition = humanoidRootPart.Position - Vector3.new(0, 3, 0)

            local topVector = camera:WorldToViewportPoint(topPosition)
            local bottomVector = camera:WorldToViewportPoint(bottomPosition)

            local height = math.abs(topVector.Y - bottomVector.Y)
            local width = height * 0.6

            local boxPosition = Vector2.new(vector.X - width / 2, vector.Y - height / 2)
            local boxSize = Vector2.new(width, height)

            -- C·∫≠p nh·∫≠t Box
            boxObject.Box.Position = boxPosition
            boxObject.Box.Size = boxSize
            boxObject.Box.Visible = true
            boxObject.Box.Thickness = BoxStroke

            -- C·∫≠p nh·∫≠t m√†u Rainbow n·∫øu b·∫≠t
            boxObject.Box.Color = RainbowEnabled and getRainbowColor() or Color3.fromRGB(255, 255, 255)
        else
            boxObject.Box.Visible = false
        end
    end
end)



local function toggleESPTracer(state)
    _G.ESPEnabled = state
    if state then
         sound:Play()
        for _, player in pairs(Players:GetPlayers()) do
            createTracer(player)
        end
    else
        sound:Play()
        for _, tracer in pairs(tracers) do
            tracer.Visible = false
        end
    end
end


Players.PlayerAdded:Connect(createTracer)
Players.PlayerAdded:Connect(CreateBoxForPlayer)
Players.PlayerAdded:Connect(createNameTag)
Players.PlayerRemoving:Connect(function(player)
    if tracers[player] then
        tracers[player]:Remove()
        tracers[player] = nil
    end
    if nameTags[player] then
        nameTags[player]:Remove()
        nameTags[player] = nil
    end
end)
RunService.RenderStepped:Connect(updateTracers)
RunService.RenderStepped:Connect(updateNameTags)

local Tile1 = Tab3:CreateSection("ESP")
-- N√∫t b·∫≠t/t·∫Øt ESP Tracer
local espToggle = Tab3:CreateToggle({
    Name = "ESP Tracer",
    Default = false,
    Flag = "Tracer",
    Callback = function(Value)
        toggleESPTracer(Value)
    end
})

-- T·∫°o tab UI cho Box
Tab3:CreateToggle({
    Name = "Turn Box On/Off",
    Default = false,
    Flag = "Box",
    Callback = function(Value)
        ToggleBox(Value)
    end
})

-- Th√™m n√∫t b·∫≠t/t·∫Øt ESP Name
local nameEspToggle = Tab3:CreateToggle({
    Name = "ESP Name",
    Default = false,
    Flag = "Name",
    Callback = function(Value)
        toggleNameESP(Value)
    end
})

-- Th√™m Toggle b·∫≠t/t·∫Øt ch·∫ø ƒë·ªô Rainbow
local RainbowEsp = Tab3:CreateToggle({
    Name = "Turn Rainbow mode on/off",
    Default = false,
    Flag = "RainbowESP",
    Callback = function(Value)
        sound:Play()
        _G.RainbowEnabled = Value
        RainbowEnabled = Value
    end
})

local Tile2 = Tab3:CreateSection("Setting")

-- N√∫t b·∫≠t/t·∫Øt Team Check cho Tracer
local teamCheckToggle = Tab3:CreateToggle({
    Name = "Team Check ESP",
    Default = false,
    Flag = "TeamcheckESP",
    Callback = function(Value)
        sound:Play()
        _G.TeamCheckTracer = Value
        _G.TeamCheck = Value
    end
})

-- Slider ch·ªânh k√≠ch th∆∞·ªõc ch·ªØ ESP Name
local nameSizeSlider = Tab3:CreateSlider({
    Name = "ESP Name font size",
    Range = {10, 30},
    Increment = 1,
    CurrentValue = 12,
    Flag = "SizeESPName",
    Callback = function(Value)
        _G.NameESPFontSize = Value
        for _, nameTag in pairs(nameTags) do
            nameTag.Size = Value
        end
    end
})

-- Slider ch·ªânh ƒë·ªô d√†y c·ªßa tracer
local tracerThicknessSlider = Tab3:CreateSlider({
    Name = "Tracer Thickness",
    Range = {1, 5},
    Increment = 1,
    CurrentValue = 1,
    Flag = "TracerThickness",
    Callback = function(Value)
        for _, tracer in pairs(tracers) do
            tracer.Thickness = Value
        end
    end
})

Tab3:CreateSlider({
    Name = "Box Border Thickness",
    Range = {1, 5}, -- Gi√° tr·ªã t·ª´ 1 ƒë·∫øn 5
    Increment = 1, -- TƒÉng t·ª´ng ƒë∆°n v·ªã
    CurrentValue = BoxStroke, -- Gi√° tr·ªã m·∫∑c ƒë·ªãnh
    Flag = "Box Stroke",
    Callback = function(Value)
        UpdateStroke(Value)
    end
})

Rayfield:LoadConfiguration()